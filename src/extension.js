const vscode = require('vscode');

let keywords = {
  ["abstract"]: new vscode.MarkdownString("Type is abstract."),
  ["ansi"]: new vscode.MarkdownString("Marshal strings to platform as ANSI."),
  ["auto"]: new vscode.MarkdownString("Layout of fields is provided automatically."),
  ["autochar"]: new vscode.MarkdownString("Marshal strings to platform as ANSI or Unicode (platform-specific)."),
  ["beforefieldinit"]: new vscode.MarkdownString("Need not initialize the type before a static method is called."),
  ["explicit"]: new vscode.MarkdownString("Layout of fields is provided explicitly."),
  ["interface"]: new vscode.MarkdownString("Declares an interface."),
  ["nested assembly"]: new vscode.MarkdownString("Assembly accessibility for nested type."),
  ["nested famandassem"]: new vscode.MarkdownString("Family and assembly accessibility for nested type."),
  ["nested family"]: new vscode.MarkdownString("Family accessibility for nested type."),
  ["nested famorassem"]: new vscode.MarkdownString("Family or assembly accessibility for nested type."),
  ["nested private"]: new vscode.MarkdownString("Private accessibility for nested type."),
  ["nested public"]: new vscode.MarkdownString("Public accessibility for nested type."),
  ["private"]: new vscode.MarkdownString("Private visibility of top-level type."),
  ["public"]: new vscode.MarkdownString("Public visibility of top-level type."),
  ["rtspecialname"]: new vscode.MarkdownString("Special treatment by runtime."),
  ["sealed"]: new vscode.MarkdownString("The type cannot be derived from."),
  ["sequential"]: new vscode.MarkdownString("Layout of fields is sequential."),
  ["serializable"]: new vscode.MarkdownString("Reserved (to indicate this type can be serialized)."),
  ["specialname"]: new vscode.MarkdownString("Might get special treatment by tools."),
  ["unicode"]: new vscode.MarkdownString("Marshal strings to platform as Unicode."),

  ["xor"]: new vscode.MarkdownString().appendCodeblock("xor").appendMarkdown("Bitwise XOR of integer values, returns an integer."),
  ["volatile."]: new vscode.MarkdownString().appendCodeblock("volatile.").appendMarkdown("Subsequent pointer reference is volatile."),
  ["unbox.any"]: new vscode.MarkdownString().appendCodeblock("unbox.any <typeTok>").appendMarkdown("Extract a value-type from obj, its boxed representation, and copy to the top of the stack."),
  ["unbox"]: new vscode.MarkdownString().appendCodeblock("unbox <valuetype>").appendMarkdown("Extract a value-type from obj, its boxed representation, and push a controlled-mutability managed pointer to it to the top of the stack."),
  ["unaligned."]: new vscode.MarkdownString().appendCodeblock("unaligned. (alignment)").appendMarkdown("Subsequent pointer instruction might be unaligned."),
  ["throw"]: new vscode.MarkdownString().appendCodeblock("throw").appendMarkdown("Throw an exception."),
  ["tail."]: new vscode.MarkdownString().appendCodeblock("tail.").appendMarkdown("Subsequent call terminates current method."),
  ["switch"]: new vscode.MarkdownString().appendCodeblock("switch <uint32, int32, int32 (t1..tN)>").appendMarkdown("Jump to one of n values."),
  ["sub.ovf.un"]: new vscode.MarkdownString().appendCodeblock("sub.ovf.un").appendMarkdown("Subtract  `native unsigned int` from a  `native unsigned int`. Unsigned result shall fit in same size."),
  ["sub.ovf"]: new vscode.MarkdownString().appendCodeblock("sub.ovf").appendMarkdown("Subtract `native int` from a `native int`. Signed result shall fit in same size."),
  ["sub"]: new vscode.MarkdownString().appendCodeblock("sub").appendMarkdown("Subtract value2 from value1, returning a new value."),
  ["stsfld"]: new vscode.MarkdownString().appendCodeblock("stsfld <field>").appendMarkdown("Replace the value of the static field with val."),
  ["stobj"]: new vscode.MarkdownString().appendCodeblock("stobj <typeTok>").appendMarkdown("Store a value of type typeTok at an address."),
  ["stloc.s"]: new vscode.MarkdownString().appendCodeblock("stloc.s <uint8 (indx)>").appendMarkdown("Pop a value from stack into local variable indx, short form."),
  ["stloc.3"]: new vscode.MarkdownString().appendCodeblock("stloc.3").appendMarkdown("Pop a value from stack into local variable 3."),
  ["stloc.2"]: new vscode.MarkdownString().appendCodeblock("stloc.2").appendMarkdown("Pop a value from stack into local variable 2."),
  ["stloc.1"]: new vscode.MarkdownString().appendCodeblock("stloc.1").appendMarkdown("Pop a value from stack into local variable 1."),
  ["stloc.0"]: new vscode.MarkdownString().appendCodeblock("stloc.0").appendMarkdown("Pop a value from stack into local variable 0."),
  ["stloc"]: new vscode.MarkdownString().appendCodeblock("stloc <uint16 (indx)>").appendMarkdown("Pop a value from stack into local variable indx."),
  ["stind.ref"]: new vscode.MarkdownString().appendCodeblock("stind.ref").appendMarkdown("Store value of type object ref (type `O`) into memory at address."),
  ["stind.r8"]: new vscode.MarkdownString().appendCodeblock("stind.r8").appendMarkdown("Store value of type `float64` into memory at address."),
  ["stind.r4"]: new vscode.MarkdownString().appendCodeblock("stind.r4").appendMarkdown("Store value of type `float32` into memory at address."),
  ["stind.i8"]: new vscode.MarkdownString().appendCodeblock("stind.i8").appendMarkdown("Store value of type `int64` into memory at address."),
  ["stind.i4"]: new vscode.MarkdownString().appendCodeblock("stind.i4").appendMarkdown("Store value of type `int32` into memory at address."),
  ["stind.i2"]: new vscode.MarkdownString().appendCodeblock("stind.i2").appendMarkdown("Store value of type `int16` into memory at address."),
  ["stind.i1"]: new vscode.MarkdownString().appendCodeblock("stind.i1").appendMarkdown("Store value of type `int8` into memory at address."),
  ["stind.i"]: new vscode.MarkdownString().appendCodeblock("stind.i").appendMarkdown("Store value of type `native int` into memory at address."),
  ["stfld"]: new vscode.MarkdownString().appendCodeblock("stfld <field>").appendMarkdown("Replace the value of field of the object obj with value."),
  ["stelem.ref"]: new vscode.MarkdownString().appendCodeblock("stelem.ref").appendMarkdown("Replace array element at index with the ref value on the stack."),
  ["stelem.r8"]: new vscode.MarkdownString().appendCodeblock("stelem.r8").appendMarkdown("Replace array element at index with the `float64` value on the stack."),
  ["stelem.r4"]: new vscode.MarkdownString().appendCodeblock("stelem.r4").appendMarkdown("Replace array element at index with the `float32` value on the stack."),
  ["stelem.i8"]: new vscode.MarkdownString().appendCodeblock("stelem.i8").appendMarkdown("Replace array element at index with the `int64` value on the stack."),
  ["stelem.i4"]: new vscode.MarkdownString().appendCodeblock("stelem.i4").appendMarkdown("Replace array element at index with the `int32` value on the stack."),
  ["stelem.i2"]: new vscode.MarkdownString().appendCodeblock("stelem.i2").appendMarkdown("Replace array element at index with the `int16` value on the stack."),
  ["stelem.i1"]: new vscode.MarkdownString().appendCodeblock("stelem.i1").appendMarkdown("Replace array element at index with the `int8` value on the stack."),
  ["stelem.i"]: new vscode.MarkdownString().appendCodeblock("stelem.i").appendMarkdown("Replace array element at index with the i value on the stack."),
  ["stelem"]: new vscode.MarkdownString().appendCodeblock("stelem <typeTok>").appendMarkdown("Replace array element at index with the value on the stack."),
  ["starg.s"]: new vscode.MarkdownString().appendCodeblock("starg.s <uint8 (num)>").appendMarkdown("Store value to the argument numbered num, short form."),
  ["starg"]: new vscode.MarkdownString().appendCodeblock("starg <uint16 (num)>").appendMarkdown("Store value to the argument numbered num."),
  ["sizeof"]: new vscode.MarkdownString().appendCodeblock("sizeof <typeTok>").appendMarkdown("Push the size, in bytes, of a type as an `unsigned int32`."),
  ["shr.un"]: new vscode.MarkdownString().appendCodeblock("shr.un").appendMarkdown("Shift an integer right (shift in zero), return an integer."),
  ["shr"]: new vscode.MarkdownString().appendCodeblock("shr").appendMarkdown("Shift an integer right (shift in sign), return an integer."),
  ["shl"]: new vscode.MarkdownString().appendCodeblock("shl").appendMarkdown("Shift an integer left (shifting in zeros), return an integer."),
  ["rethrow"]: new vscode.MarkdownString().appendCodeblock("rethrow").appendMarkdown("Rethrow the current exception."),
  ["ret"]: new vscode.MarkdownString().appendCodeblock("ret").appendMarkdown("Return from method, possibly with a value."),
  ["rem.un"]: new vscode.MarkdownString().appendCodeblock("rem.un").appendMarkdown("Remainder when dividing one unsigned value by another."),
  ["rem"]: new vscode.MarkdownString().appendCodeblock("rem").appendMarkdown("Remainder when dividing one value by another."),
  ["refanyval"]: new vscode.MarkdownString().appendCodeblock("refanyval <type>").appendMarkdown("Push the address stored in a typed reference."),
  ["refanytype"]: new vscode.MarkdownString().appendCodeblock("refanytype").appendMarkdown("Push the type token stored in a typed reference."),
  ["readonly."]: new vscode.MarkdownString().appendCodeblock("readonly.").appendMarkdown("Specify that the subsequent array address operation performs no type check at runtime, and that it returns a controlled-mutability managed pointer."),
  ["pop"]: new vscode.MarkdownString().appendCodeblock("pop").appendMarkdown("Pop value from the stack."),
  ["or"]: new vscode.MarkdownString().appendCodeblock("or").appendMarkdown("Bitwise OR of two integer values, returns an integer."),
  ["not"]: new vscode.MarkdownString().appendCodeblock("not").appendMarkdown("Bitwise complement."),
  ["nop"]: new vscode.MarkdownString().appendCodeblock("nop").appendMarkdown("Do nothing (No operation)."),
  ["no."]: new vscode.MarkdownString().appendCodeblock("no. { typecheck, rangecheck, nullcheck }").appendMarkdown("The specified fault check(s) normally performed as part of the execution of the subsequent instruction can/shall be skipped."),
  ["newobj"]: new vscode.MarkdownString().appendCodeblock("newobj <ctor>").appendMarkdown("Allocate an uninitialized object or value type and call ctor."),
  ["newarr"]: new vscode.MarkdownString().appendCodeblock("newarr <etype>").appendMarkdown("Create a new array with elements of type etype."),
  ["neg"]: new vscode.MarkdownString().appendCodeblock("neg").appendMarkdown("Negate value."),
  ["mul.ovf.un"]: new vscode.MarkdownString().appendCodeblock("mul.ovf.un").appendMarkdown("Multiply unsigned integer values. Unsigned result shall fit in same size."),
  ["mul.ovf"]: new vscode.MarkdownString().appendCodeblock("mul.ovf").appendMarkdown("Multiply signed integer values. Signed result shall fit in same size."),
  ["mul"]: new vscode.MarkdownString().appendCodeblock("mul").appendMarkdown("Multiply values."),
  ["mkrefany"]: new vscode.MarkdownString().appendCodeblock("mkrefany <class>").appendMarkdown("Push a typed reference to ptr of type class onto the stack."),
  ["localloc"]: new vscode.MarkdownString().appendCodeblock("localloc").appendMarkdown("Allocate space from the local memory pool."),
  ["leave.s"]: new vscode.MarkdownString().appendCodeblock("leave.s <int8 (target)>").appendMarkdown("Exit a protected region of code, short form."),
  ["leave"]: new vscode.MarkdownString().appendCodeblock("leave <int32 (target)>").appendMarkdown("Exit a protected region of code."),
  ["ldvirtftn"]: new vscode.MarkdownString().appendCodeblock("ldvirtftn <method>").appendMarkdown("Push address of virtual method on the stack."),
  ["ldtoken"]: new vscode.MarkdownString().appendCodeblock("ldtoken <token>").appendMarkdown("Convert metadata token to its runtime representation."),
  ["ldstr"]: new vscode.MarkdownString().appendCodeblock("ldstr <string>").appendMarkdown("Push a string object for the literal string."),
  ["ldsflda"]: new vscode.MarkdownString().appendCodeblock("ldsflda <field>").appendMarkdown("Push the address of the static field, field, on the stack."),
  ["ldsfld"]: new vscode.MarkdownString().appendCodeblock("ldsfld <field>").appendMarkdown("Push the value of the static field on the stack."),
  ["ldobj"]: new vscode.MarkdownString().appendCodeblock("ldobj <typeTok>").appendMarkdown("Copy the value stored at address src to the stack."),
  ["ldnull"]: new vscode.MarkdownString().appendCodeblock("ldnull").appendMarkdown("Push a null reference on the stack."),
  ["ldloca.s"]: new vscode.MarkdownString().appendCodeblock("ldloca.s <uint8 (indx)>").appendMarkdown("Load address of local variable with index indx, short form."),
  ["ldloca"]: new vscode.MarkdownString().appendCodeblock("ldloca <uint16 (indx)>").appendMarkdown("Load address of local variable with index indx."),
  ["ldloc.s"]: new vscode.MarkdownString().appendCodeblock("ldloc.s <uint8 (indx)>").appendMarkdown("Load local variable of index indx onto stack, short form."),
  ["ldloc.3"]: new vscode.MarkdownString().appendCodeblock("ldloc.3").appendMarkdown("Load local variable 3 onto stack."),
  ["ldloc.2"]: new vscode.MarkdownString().appendCodeblock("ldloc.2").appendMarkdown("Load local variable 2 onto stack."),
  ["ldloc.1"]: new vscode.MarkdownString().appendCodeblock("ldloc.1").appendMarkdown("Load local variable 1 onto stack."),
  ["ldloc.0"]: new vscode.MarkdownString().appendCodeblock("ldloc.0").appendMarkdown("Load local variable 0 onto stack."),
  ["ldloc"]: new vscode.MarkdownString().appendCodeblock("ldloc <uint16 (indx)>").appendMarkdown("Load local variable of index indx onto stack."),
  ["ldlen"]: new vscode.MarkdownString().appendCodeblock("ldlen").appendMarkdown("Push the length (of type  `native unsigned int`) of array on the stack."),
  ["ldind.u8"]: new vscode.MarkdownString().appendCodeblock("ldind.u8").appendMarkdown("Indirect load value of type `unsigned int64` as `int64` on the stack (alias for ldind.i8)."),
  ["ldind.u4"]: new vscode.MarkdownString().appendCodeblock("ldind.u4").appendMarkdown("Indirect load value of type `unsigned int32` as `int32` on the stack."),
  ["ldind.u2"]: new vscode.MarkdownString().appendCodeblock("ldind.u2").appendMarkdown("Indirect load value of type `unsigned int16` as `int32` on the stack."),
  ["ldind.u1"]: new vscode.MarkdownString().appendCodeblock("ldind.u1").appendMarkdown("Indirect load value of type `unsigned int8` as `int32` on the stack."),
  ["ldind.ref"]: new vscode.MarkdownString().appendCodeblock("ldind.ref").appendMarkdown("Indirect load value of type object ref as `O` on the stack."),
  ["ldind.r8"]: new vscode.MarkdownString().appendCodeblock("ldind.r8").appendMarkdown("Indirect load value of type `float64` as `F` on the stack."),
  ["ldind.r4"]: new vscode.MarkdownString().appendCodeblock("ldind.r4").appendMarkdown("Indirect load value of type `float32` as `F` on the stack."),
  ["ldind.i8"]: new vscode.MarkdownString().appendCodeblock("ldind.i8").appendMarkdown("Indirect load value of type `int64` as `int64` on the stack."),
  ["ldind.i4"]: new vscode.MarkdownString().appendCodeblock("ldind.i4").appendMarkdown("Indirect load value of type `int32` as `int32` on the stack."),
  ["ldind.i2"]: new vscode.MarkdownString().appendCodeblock("ldind.i2").appendMarkdown("Indirect load value of type `int16` as `int32` on the stack."),
  ["ldind.i1"]: new vscode.MarkdownString().appendCodeblock("ldind.i1").appendMarkdown("Indirect load value of type `int8` as `int32` on the stack."),
  ["ldind.i"]: new vscode.MarkdownString().appendCodeblock("ldind.i").appendMarkdown("Indirect load value of type `native int` as `native int` on the stack."),
  ["ldftn"]: new vscode.MarkdownString().appendCodeblock("ldftn <method>").appendMarkdown("Push a pointer to a method referenced by method, on the stack."),
  ["ldflda"]: new vscode.MarkdownString().appendCodeblock("ldflda <field>").appendMarkdown("Push the address of field of object obj on the stack."),
  ["ldfld"]: new vscode.MarkdownString().appendCodeblock("ldfld <field>").appendMarkdown("Push the value of field of object (or value type) obj, onto the stack."),
  ["ldelema"]: new vscode.MarkdownString().appendCodeblock("ldelema <class>").appendMarkdown("Load the address of element at index onto the top of the stack."),
  ["ldelem.u8"]: new vscode.MarkdownString().appendCodeblock("ldelem.u8").appendMarkdown("Load the element with type `unsigned int64` at index onto the top of the stack as an `int64` (alias for ldelem.i8)."),
  ["ldelem.u4"]: new vscode.MarkdownString().appendCodeblock("ldelem.u4").appendMarkdown("Load the element with type `unsigned int32` at index onto the top of the stack as an `int32`."),
  ["ldelem.u2"]: new vscode.MarkdownString().appendCodeblock("ldelem.u2").appendMarkdown("Load the element with type `unsigned int16` at index onto the top of the stack as an `int32`."),
  ["ldelem.u1"]: new vscode.MarkdownString().appendCodeblock("ldelem.u1").appendMarkdown("Load the element with type `unsigned int8` at index onto the top of the stack as an `int32`."),
  ["ldelem.ref"]: new vscode.MarkdownString().appendCodeblock("ldelem.ref").appendMarkdown("Load the element at index onto the top of the stack as an `O`. The type of the `O` is the same as the element type of the array pushed on the CIL stack."),
  ["ldelem.r8"]: new vscode.MarkdownString().appendCodeblock("ldelem.r8").appendMarkdown("Load the element with type `float64` at index onto the top of the stack as an `F`."),
  ["ldelem.r4"]: new vscode.MarkdownString().appendCodeblock("ldelem.r4").appendMarkdown("Load the element with type `float32` at index onto the top of the stack as an `F`."),
  ["ldelem.i8"]: new vscode.MarkdownString().appendCodeblock("ldelem.i8").appendMarkdown("Load the element with type `int64` at index onto the top of the stack as an `int64`."),
  ["ldelem.i4"]: new vscode.MarkdownString().appendCodeblock("ldelem.i4").appendMarkdown("Load the element with type `int32` at index onto the top of the stack as an `int32`."),
  ["ldelem.i2"]: new vscode.MarkdownString().appendCodeblock("ldelem.i2").appendMarkdown("Load the element with type `int16` at index onto the top of the stack as an `int32`."),
  ["ldelem.i1"]: new vscode.MarkdownString().appendCodeblock("ldelem.i1").appendMarkdown("Load the element with type `int8` at index onto the top of the stack as an `int32`."),
  ["ldelem.i"]: new vscode.MarkdownString().appendCodeblock("ldelem.i").appendMarkdown("Load the element with type `native int` at index onto the top of the stack as a `native int`."),
  ["ldelem"]: new vscode.MarkdownString().appendCodeblock("ldelem <typeTok>").appendMarkdown("Loads the element at `index` onto the top of the stack as type `typeTok`."),
  ["ldc.r8"]: new vscode.MarkdownString().appendCodeblock("ldc.r8 <float64 (num)>").appendMarkdown("Push num of type `float64` onto the stack as `F`."),
  ["ldc.r4"]: new vscode.MarkdownString().appendCodeblock("ldc.r4 <float32 (num)>").appendMarkdown("Push num of type `float32` onto the stack as `F`."),
  ["ldc.i8"]: new vscode.MarkdownString().appendCodeblock("ldc.i8 <int64 (num)>").appendMarkdown("Push num of type `int64` onto the stack as `int64`."),
  ["ldc.i4.s"]: new vscode.MarkdownString().appendCodeblock("ldc.i4.s <int8 (num)>").appendMarkdown("Push num onto the stack as `int32`, short form."),
  ["ldc.i4.M1"]: new vscode.MarkdownString().appendCodeblock("ldc.i4.M1").appendMarkdown("Push -1 onto the stack as `int32` (alias for ldc.i4.m1)."),
  ["ldc.i4.m1"]: new vscode.MarkdownString().appendCodeblock("ldc.i4.m1").appendMarkdown("Push -1 onto the stack as `int32`."),
  ["ldc.i4.8"]: new vscode.MarkdownString().appendCodeblock("ldc.i4.8").appendMarkdown("Push 8 onto the stack as `int32`."),
  ["ldc.i4.7"]: new vscode.MarkdownString().appendCodeblock("ldc.i4.7").appendMarkdown("Push 7 onto the stack as `int32`."),
  ["ldc.i4.6"]: new vscode.MarkdownString().appendCodeblock("ldc.i4.6").appendMarkdown("Push 6 onto the stack as `int32`."),
  ["ldc.i4.5"]: new vscode.MarkdownString().appendCodeblock("ldc.i4.5").appendMarkdown("Push 5 onto the stack as `int32`."),
  ["ldc.i4.4"]: new vscode.MarkdownString().appendCodeblock("ldc.i4.4").appendMarkdown("Push 4 onto the stack as `int32`."),
  ["ldc.i4.3"]: new vscode.MarkdownString().appendCodeblock("ldc.i4.3").appendMarkdown("Push 3 onto the stack as `int32`."),
  ["ldc.i4.2"]: new vscode.MarkdownString().appendCodeblock("ldc.i4.2").appendMarkdown("Push 2 onto the stack as `int32`."),
  ["ldc.i4.1"]: new vscode.MarkdownString().appendCodeblock("ldc.i4.1").appendMarkdown("Push 1 onto the stack as `int32`."),
  ["ldc.i4.0"]: new vscode.MarkdownString().appendCodeblock("ldc.i4.0").appendMarkdown("Push 0 onto the stack as `int32`."),
  ["ldc.i4"]: new vscode.MarkdownString().appendCodeblock("ldc.i4 <int32 (num)>").appendMarkdown("Push num of type `int32` onto the stack as `int32`."),
  ["ldarga.s"]: new vscode.MarkdownString().appendCodeblock("ldarga.s <uint8 (argNum)>").appendMarkdown("Fetch the address of argument argNum, short form."),
  ["ldarga"]: new vscode.MarkdownString().appendCodeblock("ldarga <uint16 (argNum)>").appendMarkdown("Fetch the address of argument argNum."),
  ["ldarg.s"]: new vscode.MarkdownString().appendCodeblock("ldarg.s <uint8 (num)>").appendMarkdown("Load argument numbered num onto the stack, short form."),
  ["ldarg.3"]: new vscode.MarkdownString().appendCodeblock("ldarg.3").appendMarkdown("Load argument 3 onto the stack."),
  ["ldarg.2"]: new vscode.MarkdownString().appendCodeblock("ldarg.2").appendMarkdown("Load argument 2 onto the stack."),
  ["ldarg.1"]: new vscode.MarkdownString().appendCodeblock("ldarg.1").appendMarkdown("Load argument 1 onto the stack."),
  ["ldarg.0"]: new vscode.MarkdownString().appendCodeblock("ldarg.0").appendMarkdown("Load argument 0 onto the stack."),
  ["ldarg"]: new vscode.MarkdownString().appendCodeblock("ldarg <uint16 (num)>").appendMarkdown("Load argument numbered num onto the stack."),
  ["jmp"]: new vscode.MarkdownString().appendCodeblock("jmp <method>").appendMarkdown("Exit current method and jump to the specified method."),
  ["isinst"]: new vscode.MarkdownString().appendCodeblock("isinst <class>").appendMarkdown("Test if obj is an instance of class, returning null or an instance of that class or interface."),
  ["initobj"]: new vscode.MarkdownString().appendCodeblock("initobj <typeTok>").appendMarkdown("Initialize the value at address dest."),
  ["initblk"]: new vscode.MarkdownString().appendCodeblock("initblk").appendMarkdown("Set all bytes in a block of memory to a given byte value."),
  ["endfinally"]: new vscode.MarkdownString().appendCodeblock("endfinally").appendMarkdown("End finally clause of an exception block."),
  ["endfilter"]: new vscode.MarkdownString().appendCodeblock("endfilter").appendMarkdown("End an exception handling filter clause."),
  ["endfault"]: new vscode.MarkdownString().appendCodeblock("endfault").appendMarkdown("End fault clause of an exception block."),
  ["dup"]: new vscode.MarkdownString().appendCodeblock("dup").appendMarkdown("Duplicate the value on the top of the stack."),
  ["div.un"]: new vscode.MarkdownString().appendCodeblock("div.un").appendMarkdown("Divide two values, unsigned, returning a quotient."),
  ["div"]: new vscode.MarkdownString().appendCodeblock("div").appendMarkdown("Divide two values to return a quotient or floating-point result."),
  ["cpobj"]: new vscode.MarkdownString().appendCodeblock("cpobj <typeTok>").appendMarkdown("Copy a value type from src to dest."),
  ["cpblk"]: new vscode.MarkdownString().appendCodeblock("cpblk").appendMarkdown("Copy data from memory to memory."),
  ["conv.u8"]: new vscode.MarkdownString().appendCodeblock("conv.u8").appendMarkdown("Convert to `unsigned int64`, pushing `int64` on stack."),
  ["conv.u4"]: new vscode.MarkdownString().appendCodeblock("conv.u4").appendMarkdown("Convert to `unsigned int32`, pushing `int32` on stack."),
  ["conv.u2"]: new vscode.MarkdownString().appendCodeblock("conv.u2").appendMarkdown("Convert to `unsigned int16`, pushing `int32` on stack."),
  ["conv.u1"]: new vscode.MarkdownString().appendCodeblock("conv.u1").appendMarkdown("Convert to `unsigned int8`, pushing `int32` on stack."),
  ["conv.u"]: new vscode.MarkdownString().appendCodeblock("conv.u").appendMarkdown("Convert to  `native unsigned int`, pushing `native int` on stack."),
  ["conv.r8"]: new vscode.MarkdownString().appendCodeblock("conv.r8").appendMarkdown("Convert to `float64`, pushing `F` on stack."),
  ["conv.r4"]: new vscode.MarkdownString().appendCodeblock("conv.r4").appendMarkdown("Convert to `float32`, pushing `F` on stack."),
  ["conv.r.un"]: new vscode.MarkdownString().appendCodeblock("conv.r.un").appendMarkdown("Convert unsigned integer to floating-point, pushing `F` on stack."),
  ["conv.ovf.u8.un"]: new vscode.MarkdownString().appendCodeblock("conv.ovf.u8.un").appendMarkdown("Convert unsigned to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow."),
  ["conv.ovf.u8"]: new vscode.MarkdownString().appendCodeblock("conv.ovf.u8").appendMarkdown("Convert to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow."),
  ["conv.ovf.u4.un"]: new vscode.MarkdownString().appendCodeblock("conv.ovf.u4.un").appendMarkdown("Convert unsigned to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow."),
  ["conv.ovf.u4"]: new vscode.MarkdownString().appendCodeblock("conv.ovf.u4").appendMarkdown("Convert to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow."),
  ["conv.ovf.u2.un"]: new vscode.MarkdownString().appendCodeblock("conv.ovf.u2.un").appendMarkdown("Convert unsigned to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow."),
  ["conv.ovf.u2"]: new vscode.MarkdownString().appendCodeblock("conv.ovf.u2").appendMarkdown("Convert to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow."),
  ["conv.ovf.u1.un"]: new vscode.MarkdownString().appendCodeblock("conv.ovf.u1.un").appendMarkdown("Convert unsigned to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow."),
  ["conv.ovf.u1"]: new vscode.MarkdownString().appendCodeblock("conv.ovf.u1").appendMarkdown("Convert to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow."),
  ["conv.ovf.u.un"]: new vscode.MarkdownString().appendCodeblock("conv.ovf.u.un").appendMarkdown("Convert unsigned to a  `native unsigned int` (on the stack as `native int`) and throw an exception on overflow."),
  ["conv.ovf.u"]: new vscode.MarkdownString().appendCodeblock("conv.ovf.u").appendMarkdown("Convert to a  `native unsigned int` (on the stack as `native int`) and throw an exception on overflow."),
  ["conv.ovf.i8.un"]: new vscode.MarkdownString().appendCodeblock("conv.ovf.i8.un").appendMarkdown("Convert unsigned to an `int64` (on the stack as `int64`) and throw an exception on overflow."),
  ["conv.ovf.i8"]: new vscode.MarkdownString().appendCodeblock("conv.ovf.i8").appendMarkdown("Convert to an `int64` (on the stack as `int64`) and throw an exception on overflow."),
  ["conv.ovf.i4.un"]: new vscode.MarkdownString().appendCodeblock("conv.ovf.i4.un").appendMarkdown("Convert unsigned to an `int32` (on the stack as `int32`) and throw an exception on overflow."),
  ["conv.ovf.i4"]: new vscode.MarkdownString().appendCodeblock("conv.ovf.i4").appendMarkdown("Convert to an `int32` (on the stack as `int32`) and throw an exception on overflow."),
  ["conv.ovf.i2.un"]: new vscode.MarkdownString().appendCodeblock("conv.ovf.i2.un").appendMarkdown("Convert unsigned to an `int16` (on the stack as `int32`) and throw an exception on overflow."),
  ["conv.ovf.i2"]: new vscode.MarkdownString().appendCodeblock("conv.ovf.i2").appendMarkdown("Convert to an `int16` (on the stack as `int32`) and throw an exception on overflow."),
  ["conv.ovf.i1.un"]: new vscode.MarkdownString().appendCodeblock("conv.ovf.i1.un").appendMarkdown("Convert unsigned to an `int8` (on the stack as `int32`) and throw an exception on overflow."),
  ["conv.ovf.i1"]: new vscode.MarkdownString().appendCodeblock("conv.ovf.i1").appendMarkdown("Convert to an `int8` (on the stack as `int32`) and throw an exception on overflow."),
  ["conv.ovf.i.un"]: new vscode.MarkdownString().appendCodeblock("conv.ovf.i.un").appendMarkdown("Convert unsigned to a `native int` (on the stack as `native int`) and throw an exception on overflow."),
  ["conv.ovf.i"]: new vscode.MarkdownString().appendCodeblock("conv.ovf.i").appendMarkdown("Convert to a `native int` (on the stack as `native int`) and throw an exception on overflow."),
  ["conv.i8"]: new vscode.MarkdownString().appendCodeblock("conv.i8").appendMarkdown("Convert to `int64`, pushing `int64` on stack."),
  ["conv.i4"]: new vscode.MarkdownString().appendCodeblock("conv.i4").appendMarkdown("Convert to `int32`, pushing `int32` on stack."),
  ["conv.i2"]: new vscode.MarkdownString().appendCodeblock("conv.i2").appendMarkdown("Convert to `int16`, pushing `int32` on stack."),
  ["conv.i1"]: new vscode.MarkdownString().appendCodeblock("conv.i1").appendMarkdown("Convert to `int8`, pushing `int32` on stack."),
  ["conv.i"]: new vscode.MarkdownString().appendCodeblock("conv.i").appendMarkdown("Convert to `native int`, pushing `native int` on stack."),
  ["constrained."]: new vscode.MarkdownString().appendCodeblock("constrained. <thisType>").appendMarkdown("Call a virtual method on a type constrained to be type T."),
  ["clt.un"]: new vscode.MarkdownString().appendCodeblock("clt.un").appendMarkdown("Push 1 (of type `int32`) if value1 lower than value2, unsigned or unordered, else push 0."),
  ["clt"]: new vscode.MarkdownString().appendCodeblock("clt").appendMarkdown("Push 1 (of type `int32`) if value1 lower than value2, else push 0."),
  ["ckfinite"]: new vscode.MarkdownString().appendCodeblock("ckfinite").appendMarkdown("Throw ArithmeticException if value is not a finite number."),
  ["cgt.un"]: new vscode.MarkdownString().appendCodeblock("cgt.un").appendMarkdown("Push 1 (of type `int32`) if value1 greater that value2, unsigned or unordered, else push 0."),
  ["cgt"]: new vscode.MarkdownString().appendCodeblock("cgt").appendMarkdown("Push 1 (of type `int32`) if value1 greater that value2, else push 0."),
  ["ceq"]: new vscode.MarkdownString().appendCodeblock("ceq").appendMarkdown("Push 1 (of type `int32`) if value1 equals value2, else push 0."),
  ["castclass"]: new vscode.MarkdownString().appendCodeblock("castclass <class>").appendMarkdown("Cast obj to class."),
  ["callvirt"]: new vscode.MarkdownString().appendCodeblock("callvirt <method>").appendMarkdown("Call a method associated with an object."),
  ["calli"]: new vscode.MarkdownString().appendCodeblock("calli <callsitedescr>").appendMarkdown("Call method indicated on the stack with arguments described by callsitedescr."),
  ["call"]: new vscode.MarkdownString().appendCodeblock("call <method>").appendMarkdown("Call method described by method."),
  ["brzero.s"]: new vscode.MarkdownString().appendCodeblock("brzero.s <int8 (target)>").appendMarkdown("Branch to target if value is zero (alias for brfalse.s), short form."),
  ["brzero"]: new vscode.MarkdownString().appendCodeblock("brzero <int32 (target)>").appendMarkdown("Branch to target if value is zero (alias for brfalse)."),
  ["brtrue.s"]: new vscode.MarkdownString().appendCodeblock("brtrue.s <int8 (target)>").appendMarkdown("Branch to target if value is non-zero (true), short form."),
  ["brtrue"]: new vscode.MarkdownString().appendCodeblock("brtrue <int32 (target)>").appendMarkdown("Branch to target if value is non-zero (true)."),
  ["brnull.s"]: new vscode.MarkdownString().appendCodeblock("brnull.s <int8 (target)>").appendMarkdown("Branch to target if value is null (alias for brfalse.s), short form."),
  ["brnull"]: new vscode.MarkdownString().appendCodeblock("brnull <int32 (target)>").appendMarkdown("Branch to target if value is null (alias for brfalse)."),
  ["brinst.s"]: new vscode.MarkdownString().appendCodeblock("brinst.s <int8 (target)>").appendMarkdown("Branch to target if value is a non-null object reference, short form (alias for brtrue.s)."),
  ["brinst"]: new vscode.MarkdownString().appendCodeblock("brinst <int32 (target)>").appendMarkdown("Branch to target if value is a non-null object reference (alias for brtrue)."),
  ["brfalse.s"]: new vscode.MarkdownString().appendCodeblock("brfalse.s <int8 (target)>").appendMarkdown("Branch to target if value is zero (false), short form."),
  ["brfalse"]: new vscode.MarkdownString().appendCodeblock("brfalse <int32 (target)>").appendMarkdown("Branch to target if value is zero (false)."),
  ["break"]: new vscode.MarkdownString().appendCodeblock("break").appendMarkdown("Inform a debugger that a breakpoint has been reached."),
  ["br.s"]: new vscode.MarkdownString().appendCodeblock("br.s <int8 (target)>").appendMarkdown("Branch to target, short form."),
  ["br"]: new vscode.MarkdownString().appendCodeblock("br <int32 (target)>").appendMarkdown("Branch to target."),
  ["box"]: new vscode.MarkdownString().appendCodeblock("box <typeTok>").appendMarkdown("Convert a boxable value to its boxed form."),
  ["bne.un.s"]: new vscode.MarkdownString().appendCodeblock("bne.un.s <int8 (target)>").appendMarkdown("Branch to target if unequal or unordered, short form."),
  ["bne.un"]: new vscode.MarkdownString().appendCodeblock("bne.un <int32 (target)>").appendMarkdown("Branch to target if unequal or unordered."),
  ["blt.un.s"]: new vscode.MarkdownString().appendCodeblock("blt.un.s <int8 (target)>").appendMarkdown("Branch to target if less than (unsigned or unordered), short form."),
  ["blt.un"]: new vscode.MarkdownString().appendCodeblock("blt.un <int32 (target)>").appendMarkdown("Branch to target if less than (unsigned or unordered)."),
  ["blt.s"]: new vscode.MarkdownString().appendCodeblock("blt.s <int8 (target)>").appendMarkdown("Branch to target if less than, short form."),
  ["blt"]: new vscode.MarkdownString().appendCodeblock("blt <int32 (target)>").appendMarkdown("Branch to target if less than."),
  ["ble.un.s"]: new vscode.MarkdownString().appendCodeblock("ble.un.s <int8 (target)>").appendMarkdown("Branch to target if less than or equal to (unsigned or unordered), short form."),
  ["ble.un"]: new vscode.MarkdownString().appendCodeblock("ble.un <int32 (target)>").appendMarkdown("Branch to target if less than or equal to (unsigned or unordered)."),
  ["ble.s"]: new vscode.MarkdownString().appendCodeblock("ble.s <int8 (target)>").appendMarkdown("Branch to target if less than or equal to, short form."),
  ["ble"]: new vscode.MarkdownString().appendCodeblock("ble <int32 (target)>").appendMarkdown("Branch to target if less than or equal to."),
  ["bgt.un.s"]: new vscode.MarkdownString().appendCodeblock("bgt.un.s <int8 (target)>").appendMarkdown("Branch to target if greater than (unsigned or unordered), short form."),
  ["bgt.un"]: new vscode.MarkdownString().appendCodeblock("bgt.un <int32 (target)>").appendMarkdown("Branch to target if greater than (unsigned or unordered)."),
  ["bgt.s"]: new vscode.MarkdownString().appendCodeblock("bgt.s <int8 (target)>").appendMarkdown("Branch to target if greater than, short form."),
  ["bgt"]: new vscode.MarkdownString().appendCodeblock("bgt <int32 (target)>").appendMarkdown("Branch to target if greater than."),
  ["bge.un.s"]: new vscode.MarkdownString().appendCodeblock("bge.un.s <int8 (target)>").appendMarkdown("Branch to target if greater than or equal to (unsigned or unordered), short form."),
  ["bge.un"]: new vscode.MarkdownString().appendCodeblock("bge.un <int32 (target)>").appendMarkdown("Branch to target if greater than or equal to (unsigned or unordered)."),
  ["bge.s"]: new vscode.MarkdownString().appendCodeblock("bge.s <int8 (target)>").appendMarkdown("Branch to target if greater than or equal to, short form."),
  ["bge"]: new vscode.MarkdownString().appendCodeblock("bge <int32 (target)>").appendMarkdown("Branch to target if greater than or equal to."),
  ["beq.s"]: new vscode.MarkdownString().appendCodeblock("beq.s <int8 (target)>").appendMarkdown("Branch to target if equal, short form."),
  ["beq"]: new vscode.MarkdownString().appendCodeblock("beq <int32 (target)>").appendMarkdown("Branch to target if equal."),
  ["arglist"]: new vscode.MarkdownString().appendCodeblock("arglist").appendMarkdown("Return argument list handle for the current method."),
  ["and"]: new vscode.MarkdownString().appendCodeblock("and").appendMarkdown("Bitwise AND of two integral values, returns an integral value."),
  ["add.ovf.un"]: new vscode.MarkdownString().appendCodeblock("add.ovf.un").appendMarkdown("Add unsigned integer values with overflow check."),
  ["add.ovf"]: new vscode.MarkdownString().appendCodeblock("add.ovf").appendMarkdown("Add signed integer values with overflow check."),
  ["add"]: new vscode.MarkdownString().appendCodeblock("add").appendMarkdown("Add two values, returning a new value."),

  ["locals"]: new vscode.MarkdownString()
                        .appendCodeblock(".locals [init] (       " + "\n" +
                                         "  <type> '<identifier>'" + "\n" +
                                         "  ...                  " + "\n" +
                                         ")                      ")
                        .appendMarkdown("Defines a set of local variables for this method."),
  ["custom"]: new vscode.MarkdownString().appendCodeblock(".custom <customDecl>").appendMarkdown("Definition of custom attributes."),
  ["data"]: new vscode.MarkdownString().appendCodeblock(".data <dataDecl>").appendMarkdown("Emits data to the data section."),
  ["emitbyte"]: new vscode.MarkdownString().appendCodeblock(".emitbyte <int32>").appendMarkdown("Emits an unsigned byte to the code section of the method."),
  ["entrypoint"]: new vscode.MarkdownString().appendCodeblock(".entrypoint").appendMarkdown("Specifies that this method is the entry point to the application (only one such method is allowed)."),
  ["maxstack"]: new vscode.MarkdownString().appendCodeblock(".maxstack <int32>").appendMarkdown("The `int32` specifies the maximum number of elements on the evaluation stack during the execution of the method."),
  ["override"]: new vscode.MarkdownString().appendCodeblock(".override <type>::<method>").appendMarkdown("Use current method as the implementation for the method specified."),
  ["override method"]: new vscode.MarkdownString().appendCodeblock(".override method <callConv> <type> <type>::<method> <genArity> (<parameters>)").appendMarkdown("Use current method as the implementation for the method specified."),
  ["param"]: new vscode.MarkdownString().appendCodeblock(".param [<int32>] [=<fieldInit>]").appendMarkdown("Store a constant FieldInit value for parameter `int32`."),
  ["param type"]: new vscode.MarkdownString().appendCodeblock(".param type [<int32>]").appendMarkdown("Specifies a type parameter for a generic method."),

  ["bool"]: "True/false value",
  ["char"]: "Unicode 16-bit char.",
  ["object"]: "Object or boxed value type",
  ["string"]: "Unicode string",
  ["float32"]: "IEC 60559:1989 32-bit float",
  ["float64"]: "IEC 60559:1989 64-bit float",
  ["int8"]: "Signed 8-bit integer",
  ["int16"]: "Signed 16-bit integer",
  ["int32"]: "Signed 32-bit integer",
  ["int64"]: "Signed 64-bit integer",
  ["native int"]: "Signed integer, native size",
  ["native unsigned int"]: "Unsigned integer, native size",
  ["typedref"]: "Pointer plus exact type",
  ["unsigned int8"]: "Unsigned 8-bit integer",
  ["unsigned int16"]: "Unsigned 16-bit integer",
  ["unsigned int32"]: "Unsigned 32-bit integer",
  ["unsigned int64"]: "Unsigned 64-bit integer",
};

function activate(context) {
  vscode.languages.registerHoverProvider('il', {provideHover(document, position, token) {
    let line = document.lineAt(position);
    let lineNumber = line.range.start.line;

    let hover;
    for (let keyword of Object.keys(keywords).sort((a, b) => a.length - b.length)) {
      let index;
      if ((index = line.text.indexOf(keyword)) !== -1 && line.range.contains(new vscode.Position(lineNumber, index + keyword.length))) {
        hover = keywords[keyword];
      }
    }

    return {contents: [hover]};
  }});

  vscode.languages.registerCompletionItemProvider('il', {
    provideCompletionItems(document, position, token) {
      let word = document.getText(document.getWordRangeAtPosition(position));

      return new vscode.CompletionList(Object.keys(keywords)
                                             .filter(key => key.startsWith(word))
                                             .map(completion => {
        let item = new vscode.CompletionItem(completion);
        item.documentation = keywords[completion];

        return item;
      }));
    }
  }, ["."]);
}

module.exports = {
  activate
}